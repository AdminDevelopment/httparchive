# JavaScript Library Detection

There's a custom metric to [detect third-party JavaScript libraries](../custom_metrics/third-parties.js) included by
websites. Its signatures are based on [Library Detector](https://github.com/johnmichel/Library-Detector-for-Chrome).
The signatures work by looking for characteristic global variable names and objects in the runtime JavaScript
environment of the browser during the crawl.

## Limitations of the Detection Methodology

* Because the tests must be executed during the crawl, only libraries supported at the time of the crawl can be
  detected. Adding support for additional libraries will detect them only in future crawls, not retroactively.
* In abstract terms, each frame of a website has its own JavaScript environment and could load its own set of libraries.
  However, the crawl executes library detection tests only in the main page - this means that libraries loaded inside
  frames will go undetected.
* Some websites (accidentally or on purpose) include the same library multiple times into the same page. Since libraries
  usually register as a global variable, only one copy can be detected (the one referenced by the variable when the
  tests are run).
* The version of a library is "detected" by extracting the value of the version attribute in the library code. The
  detected version may be incorrect if a website developer modifies the version string, or if the library code returns
  the wrong version number. Some libraries don't have such a version attribute, which means they will be detected as
  present in the website, but with an unknown (`null`) version. Other libraries didn't have a version attribute from the
  start but added it later, which means that older versions of such a library will be detected as an unknown version,
  and more recent versions will be detected as the version number exported by the library.
* Because of the way the library signatures work, there's a higher potential that a detection is a "false positive" when
  no version number could be extracted.
* If a website includes libraries as a "private" reference instead of a global variable, uses heavy minification with
  dead code removal, uses obfuscation, or makes manual modifications to the library code, the signatures might fail to
  detect the library.

## Generation of the Custom Metric Script

The [third-parties.js](../custom_metrics/third-parties.js) file is generated by a nodejs script in [bin/library-detector.js](../bin/library-detector.js). Here's how it works:

1. Fetch the latest version of the [library detection config](https://raw.githubusercontent.com/johnmichel/Library-Detector-for-Chrome/master/library/libraries.js)
2. Sandwich the config between boilerplate code that iterates through it and tests each library
3. Save the generated code to `custom_metrics/third-parties.js`

This script similarly fetches `manifest.json`, extracts the repository version, and saves it to
`custom_metrics/lib-detector-version.js`. Using this metric, it's possible to go back to the specific version
of detection code used in a particular test. For example, as new libraries are added, this provides a way to differentiate
between the websites newly supporting a library and HTTP Archive newly detecting the library.

Changes to either of these custom metrics files should always be made through `bin/library-detector.js`.
Otherwise, changes will be reverted on subsequent runs of the binary.

The script has two dependencies: `node-fetch` and `fs-promise`. These are managed by NPM through the `package.json` file.
To install the dependencies and run the script, ensure you have the latest versions of `node` and `npm` installed and run:

```sh
npm install
npm run custom-metrics
```

## Deploying Updates to Custom Metrics

To push changes to the custom metrics live on the HTTP Archive server:

1. From a local git repository, run the script and commit the changes
2. Submit a PR to merge the changes into [HTTPArchive/httparchive:master](https://github.com/HTTPArchive/httparchive/tree/master)
3. SSH into the HTTP Archive server and run:

```sh
cd /var/www/httparchive.dev
git pull origin master
make pushmetrics
```
